# 数组，切片（字符串）：'append' 的运作机制

**Rob Pike**
**2013-09-26**

## 介绍

过程式编程语言的一个最常见特性就是数组的概念。数组看起来简单，但在将它们加入到一门语言之前与许多问题需要回答，比如：

- 固定大小还是可变大小？
- 大小是类型的一部分吗？
- 多维数组如何构成？
- 空数组有没有意义？

对这些问题的回答影响了数组是语言特性的一部分或者是语言设计的核心部分。

在 Go 的早期发展阶段，在设计走上正轨之前花费了约一年时间来决定对这些问题的回答。其中关键一步是切片的引入，它构建于固定大小数组之上，提供了一个弹性可扩展的数据结构。但直到今天，Go 新手程序员仍受困于切片的工作方式，可能是其它语言的体验导致了他们的思维混乱。

在本文中我试图厘清这些混淆，我们将通过构建代码片段来解释内建 `append` 函数如何工作，以及为何它以腺癌这种方式工作。

## 数组

Go 中数组是一个重要的构件，但就像建筑的基础一样，它们经常隐藏于其它可见组件之下。在谈论更有趣，更强大以及更突出的切片灵感之前，我们必须简单地介绍它们（数组）。

数组在 Go 程序中很常见，因为数组大小是其类型的一部分，这限制了其表达能力。

下面的声明：

```
var buffer [256]byte
```

声明了变量 `buffer`，它可以容纳 `256` 字节。`buffer` 类型包含其大小，`[256]byte`。一个 `512` 字节的数组是一个截然不同的类型 `[512]byte`。

与一个数组关联的数据是数组的元素。我们的 buffer 在内存中呈现如下布局：

```
buffer: byte byte byte ... 256 times ... byte byte byte
```

即这个变量除了持有 `256` 字节数据外不再持有任何东西。我们能够通过熟悉的索引语法访问其元素，`buffer[0]`, `buffer[1]`, 直至 `buffer[255]`。（索引方位从 `0` 至 `255`，包含 256 个元素）试图索引 buffer 范围之外的元素将导致程序崩溃。

有内建函数 `len` 可以返回一个数组，切片或其它一些数据类型的元素数目。对于数组，`len` 返回什么很明显。在我们的例子中，`len(buffer)` 返回固定数值 `256`。

数组有它们的位置--例如它们是转换矩阵的一个很好的表示--但是在 Go 中它们最常见的用途是持有一个切片的存储。

## 介绍


## 介绍


## 介绍


## Reference

- [数组，切片（字符串）：'append' 的运作机制](https://go.dev/blog/slices)