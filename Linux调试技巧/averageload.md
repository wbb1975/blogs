wangbb@wangbb-ThinkPad-T420:~$ uptime

21:02:30 up 40 min,  1 user,  load average: 0.89, 0.55, 0.51

它们分别是当前时间、系统运行时间以及正在登录用户数，以及过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average)。

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。

所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU的进程，也就是我们常用 ps 命令看到的，处于 R 状态（（Running 或 Runnable）的进程。

不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的　I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

因此，你可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。

既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？
- 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
- 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
- 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。

平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：
- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。

## 平均负载案例分析

你的准备:预先安装 stress 和 sysstat 包，如apt install stress sysstat。
stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。
而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。
- mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
- pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

### 场景一：CPU 密集型进程

首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：

$ stress --cpu 1 --timeout 600

接着，在第二个终端运行 uptime 查看平均负载的变化情况：

\# -d 参数表示高亮显示变化的区域

$ watch -d uptime

最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：

\# -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据

$ mpstat -P ALL 5

你可以使用 pidstat 来查询哪个进程导致了 CPU 使用率为 100%

\# 间隔 5 秒后输出一组数据

$ pidstat -u 5 1

### 场景二：I/O 密集型进程
首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync

$ stress -i 1 --timeout 600

接着，在第二个终端运行 uptime 查看平均负载的变化情况：
\# -d 参数表示高亮显示变化的区域

$ watch -d uptime

最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：

\# -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据

$ mpstat -P ALL 5

那么到底是哪个进程，导致 iowait 这么高呢？我们还是用用 pidstat 来查询：

\# 间隔 5 秒后输出一组数据

$ pidstat -u 5 1

### 场景三：大量进程的场景
当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。

$ stress -c 8 --timeout 600

接着，在第二个终端运行 uptime 查看平均负载的变化情况：
\# -d 参数表示高亮显示变化的区域

$ uptime

接着再运行 pidstat 来看一下进程的情况：

\# 间隔 5 秒后输出一组数据

$ pidstat -u 5 1

## 小结
平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：
- 平均负载高有可能是 CPU 密集型进程导致的；
- 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
- 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。
