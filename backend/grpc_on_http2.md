# gRPC On HTTP/2
## gRPC语义
作为开始，让我们首先探讨HTTP/2概念是如何与gRPC概念关联起来的：gRPC引入了三个新的概念，通道，远程过程调用（RPC）和消息。它们三个之间的关系很简单：每个通道可能含有多个远程过程调用，而每个远程过程调用可能含有许多消息。
![通道，远程过程调用和消息](images/channel_rpc_message.png)

让我们看看gRPC语义如何关联到 HTTP/2：
![gRPC语义与HTTP/2](images/grpc_http2.png)

通道是gRPC的一个关键概念。HTTP/2中的流允许在一个单个连接上的多个并发会话；通道通过跨越多个并行连接允许多个流扩展了这个概念。表面上，通道提供了简单的接口来让用户把消息发送进去；但在其背后，我们进行了大量的工作来保持这些连接活跃，健康并被使用。

通道代表至对端的虚拟连接，它事实上由许多HTTP/2连接支撑。RPC与一个连接（这个关联将深入描述）关联。RPC在实践中是简单HTTP/2 （消息）流。消息与RPC关联，并以[HTTP/2数据帧](https://http2.github.io/http2-spec/#rfc.figure.6)的形式发送。更具体地，消息在数据帧层之上。一个数据帧可能含有多个消息，或者一个gRPC消息太大以至于它需跨越多个数据帧。
## 解析器和负载均衡
为了保持连接活跃，健康并被使用，gRPC 利用了很多组件，它们之中最重要的就是名称解析器（name resolvers）和负载均衡（load balancers）。解析器将名字转换为地址，并把这些地址传递给负载均衡器。负载均衡器将负责从这些地址创建连接并在这些连接间进行负载均衡。
![解析器和负载均衡](images/resolver_loadbalancer.png)

比如，一个域名解析器（DNS resolver）可能将某个主机名解析为13个IP地址，接下来一个循环往复均衡器（RoundRobin）可能创建13个连接--每地址一个--并将RPC循环至每一个连接。一个更简单的负载均衡器可能仅仅创建与第一个地址的连接。可选地，一个用户想要多个连接，单知道主机仅仅能解析为一个地址，那么它的负载均衡器可能与每个地址创建10个连接以保证多个连接可用。

解析器和负载均衡解决了gRPC系统中小但关键的问题。设计初衷如下：减小问题空间为一些小的，分散的问题，帮助用户构建自定义组件。这些组件可被用于细粒度调优gRPC以满足各个系统的独立需求。
## 连接管理
一旦配置，gRPC将保持一个连接池，就像解析器和负载均衡定义的--连接活跃，健康并被使用。

当一个连接失败时，负载均衡器将使用最后知晓的地址列表来开始重连。同时，解析器也将试着重新解析地址列表。这在很多场景下是有用的。比如，如果代理不再可用，我们将期待解析器更新地址列表，但不包括代理地址。另举一个例子：DNS条目可能随时间更新了，地址列表可能需要定期以这种方式或那种方式更新，gRPC设计成可用于长期弹性（resiliency）。

一旦解析完成，负载均衡器将被通知有新的地址列表。如果地址已经改变了，负载均衡器可能关闭已经与不在列表上的地址的连接，并与新的地址创建连接。
## 识别失败的连接
gRPC连接管里的效率取决于它识别失败连接的能力。通常有两种类型的连接失败：干净的失败，这种失败是科沟通的；不太干静的失败，这种失败是无法沟通的。

让我们考虑一个干净的，易于观察到的失败。当一个端点有意识地杀死一个连接时，干净的失败就可能发生。比如，端点可能已经优雅地停止了或超时会提示端点关闭连接。当连接干净地关闭时，TCP语义就足够：关闭连接导致[FIN握手](http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm)发生。这结束了HTTP/2连接，进而结束了gRPC连接。gRPC将立即开始重连（正如上面描述的）。这是十分干净的且不需要额外的HTTP/2 or gRPC语义。

当端点死去或hang且没有通知客户端时，不怎么干净的失败就会发生。在连接被认为失败之前，TCP可能经历长达10分钟的重试。当然，连接失败后近10分钟才被识别出来是不可接受的。gRPC使用**HTTP/2语义**来解决这个问题：当配置KeepAlive时，gRPC将定期发送HTTP/2 PING帧。这些帧绕过流量控制用于确立连接任然活着。如果PING回复未及时返回，gRPC将认为该连接失败了，关闭并重建连接（如上面所描述的）。

通过这种方式，gRPC可以保持池内连接健康，并利用HTTP/2来探测连接健康。所有这个行为对用户是不透明的，消息定向在运行时自动发生。用户在一个看起来总是健康的池化连接上简单地发送消息。
## 保持连接活着（Keeping Connections Alive）
正如上面提到的，KeepAlive提供了很有价值的收益：通过发送HTTP/2 PING来定期检查连接的健康状态，以判断连接是否依然活着。同时它也有另一个有用的收益：把活性通知到代理。

考虑一个客户通过代理向服务器发送数。客户端和服务端都期待连接无限期活着，随需发送数据。另一方面，代理通常是资源十分受限的，其可能杀掉空闲的连接。Google云平台(GCP) 10分钟后切断明显空闲的连接，AWS弹性负载均衡器 (AWS ELBs)则在60秒后就切断空闲连接。

当gRPC定期在连接上发送HTTP/2 PING帧时，非空闲连接的感觉就将建立。使用前面提到的杀死空闲连接的规则的端点将过关，即使许多空闲连接被杀死。
## 一个健壮，高性能的协议
HTTP/2提供了长期存活的实时通讯流的基础。gRPC建立于该基础上，提供了连接池化，健康语义，数据帧的高效使用，多路复用以及保活（KeepAlive）。

开发人员选择协议时必须满足今天以及明天的需求。选择gRPC完美满足它们，它是弹性的，高性能的，满足长期活着或短期活着，可定制，或者简单讲协议可以随消息体量的巨增而扩展，性能没有多大下降。为了适应gRPC 和 HTTP/2的更新，检查[gRPC’s Getting Started](https://grpc.io/docs/)教程。

## Notes
1. 在Go中，一个gRPC通道被称之为ClientConn，这发生在“通道”一词称为一个语言中立的意思之前。
2. gRPC使用HTTP/2 的缺省最大16kb作为数据帧的大小。一个超过16kb的消息将跨越多个数据帧，另一方面，小于该大小的消息将与其它一些消息共享一个数据帧。

## Reference
- [gRPC On HTTP/2: Engineering A Robust, High Performance Protocol](https://www.cncf.io/blog/2018/08/31/grpc-on-http-2-engineering-a-robust-high-performance-protocol/)