# gRPC核心概念，架构及生命周期
对关键的gRPC概念的一个介绍，对gRPC架构及RPC生命周期的一个简单概览。
## 概观
### 服务定义
像许多RPC系统，gRPC也基于定义一个服务的概念，指定了可被远程调用的方法及其参数和返回类型。缺省地，gRPC使用[protocol buffers](https://developers.google.com/protocol-buffers)作为描述服务接口以及负荷消息结构的接口描述语言。如果需要也可使用其它选择：
```
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```
gRPC让你定义四种服务方法：
- 一元RPC：客户发送单一请求给服务端，得到一个单一回复，就像一个正常函数调用:
  ```
  rpc SayHello(HelloRequest) returns (HelloResponse);
  ```
- 服务端流式RPC：客户端向服务端发送一个请求，可得到一个流，据此都会一系列消息。客户端从返回的流读取数据直到没有更多消息。gRPC保证一个单独RPC调用里的消息顺序。
    ```
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
  ```
- 客户端流式RPC：客户端写了一系列消息并把它们发送给服务端，同样地使用一个提供的流。一旦客户写完数据，她3等待服务端读取它们并返回回复。同样地gRPC保证一个单独RPC调用里的消息顺序。
    ```
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
  ```
- 双向流式RPC：双方使用一个读写流来发送一系列消息。两个流独立运作，客户端和服务端可以任何它们喜欢的顺序读写：例如，服务端可以等到读取完所有的客户端消息再发送回复，或者它读一条消息，发送一条消息，或者其它读写组合。每个流里消息的顺序是保留的。
  ```
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
  ```
你可以在下面的RPC生命周期一节学习到更多各种RPC类型的信息。
### 使用API
从一个`.proto`文件里的服务定义开始，gRPC提供了protocol buffer编译器插件用于产生服务端和客户端代码。典型地，gRPC用户调用这些客户端APIs，再服务端实现这些API。
- 在服务端，服务器实现那些服务声明的方法病运行一个gRPC服务来处理客户调用。gRPC基础设施解码进入的请求，只性服务方法，编码服务回复。
- 在客户端，客户拥有一个本地对象叫stub，它将同样的方法实现为服务。接下来客户端在这些本地对象上调用方法，将调用参数封装成合适的pprotocol buffers消息类型--gRPC照看把请求发送到服务端，并返回服务端的pprotocol buffer回复。
### 同步异步
同步RPC调用将堵塞直到回复从服务端返回，这是与RPC渴望达成的过程调用抽象最接近的。另一方面，网络天然就是异步地，在许多场景下开始RPCs但并不堵塞当前线程是有用的。

gRPC编程API的大部分语言提供了同步异步两种方式。你可以在每种语言的教程和参考文档中找到更多。
## RPC生命周期
在这一节，你将会近距离观察到当gRPC客户端调用gRPC服务端时将会发生什么。对完整实现细节，请参考特定语言的压面。
### 一元RPC
首先考虑最简单类型的RPC--客户端发送一个单一请求并返回一个单一回复。
1. 一旦客户调用存根（stub）方法，服务端就会被通知RPC被调用，且该调用来自客户端的[元数据](https://www.grpc.io/docs/what-is-grpc/core-concepts/#metadata)，方法名，最后期限（）如果适用被传递。
2. 服务端可以马上发送它的自身初始元信息（这必须在任何回复之前发送），或者等待客户的请求消息。哪个先发生取决于不同的程序。
3. 一旦服务端拥有了客户端消息，它做其该做的工作并创建赋值回复。接下来回复与状态细节（状态吗及状态消息）被返回给客户（如果成功），同时还有可选的尾部元数据。
4. 如果回复状态是OK，客户端得到回复，从而从客户端结束此次调用。
### 服务端流式RPC
服务端流式RPC很像一元RPC，除了真对客户请求服务端再回复中返回消息流。当发送完所有休息后，服务端状态细节（状态吗及状态消息）及可选的尾部元数据被发送给客户端。这结束了服务端处理。一旦客户端收到了所有的数据它也将结束。
### 客户端流式RPC
客户端流式RPC很像一元RPC，除了客户发向服务端送消息流而不是单条休息。典型地（但非必须）在服务端收到所有的消息后，服务端回复单条休息（包含状态细节以及尾部元数据）。
### 双向流式RPC
在一个双向流式RPC中，调用由客户端发起，触发方法调用，服务器端收到客户端元信息，方法名已经最后期限。服务端可以选择发回它的初始元数据，或者等待客户的客户开始传送刘数据。

客户端和服务端流处理取决于不同的应用。因为两个流是独立的，客户端和服务端可以以任何顺序读写消息。例如，服务端可以在等待直至其收齐所有的客户端消息再发送它自己的消息，或者客户端和服务端用“ping-pong” 的方式--服务端收到一个请求，发送一个回复，接下来客户基于收到的回复发送另一个请求，如此循环不断。
### 最后期限/超时
gRPC允许客户端指定在RPC以一个DEADLINE_EXCEEDED终止之前它们愿意等待多久RPC结束。在服务端，服务器可以查询一个特定RPC是否已经超时，或该RPC还有多长时间可用。

指定一个最后期限或者超时是特定于语言的：某些语言API工作于超时术语（持续时间），有些语言工作于最后期限（一个固定时间点），可能有也可能没有一个缺省最后期限。
### RPC终止
在gRPC中，客户端和服务器端调用独立，都期待在本地成功调用，但它们的结论可能不能最终匹配。这意味着，比如，你有一个RPC在服务端成功结束(“I have sent all my responses!") ，但可能在客户端失败(“The responses arrived after my deadline!")。也有可能在客户端发送所有请求之前服务端就已经决定结束这次调用了。
### 取消RPC
客户端或服务端可在任何时刻取消RPC调用。取消操作立即终止RPC调用，没有更多的工作会被继续。
> **警告**：取消之前的修改不能回滚。
### 元数据
原信息是一个RPC调用的信息（例如[认证细节](https://www.grpc.io/docs/guides/auth)），他包含一系列键值对， 键都是字符串，值典型情况下是字符串，但也可是二进制数据。元数据对gRPC本身是不透明的--它让客户端向服务端提供调用的伴随信息，反之亦然。

元信息的访问是依赖于语言的。
### 通道
一个gRPC通道提供了一个到一个特定主机端口上的服务器的连接，它将在一个客户端存根被创建时使用。客户端可以指定通道参数以改变gRPC的行为，如开关消息压缩。一个通道拥有状态，如连接的或空闲状态。

gRPC如何关闭通道取决于使用的语言。某些语言允许查询通道状态。

## Reference
- [gRPC核心概念，架构及生命周期](https://www.grpc.io/docs/what-is-grpc/core-concepts/)