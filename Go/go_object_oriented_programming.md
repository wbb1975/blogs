# Go面向对象编程
## 1. 几个关键概念
**Go语言的面向对象之所以与C++，Java以及(较小程度上的)python这些语言如此不同，是因为它不支持继承。Go语言只支持聚合（也叫作组合）和嵌入**。为了弄明白聚合与嵌入的不同，让我们看一小段代码：
```
type ColorPoint struct {
    color.Color               //匿名字段（嵌入）
    x,y      int                    //具名字段（聚合）
}
```
这里color.Color是来自image/color包的类型，x和y则是整型。在Go语言的术语中，color.Color 、x和y都是结构体的字段，color.Color 字段是匿名的（因为它没有变量名），因此事嵌入字段。x和y是具名的聚合字段。如果我们定义`point := ColorPoint{}`，其字段可以通过point.Color、point.x和point.y来访问。

术语“类”（class），“对象”（object）以及“实例”（instance）在传统的多层次继承式面向对象编程中已经定义得非常清晰，但在Go语言中我们完全避开使用它们。相反，我们使用“类型”和“值”，其中自定义类型的值可以包含方法。

由于没有继承，因此也就没有虚函数。Go语言对此的支持则是采用类型安全的鸭子类型（duck type）。在Go语言中，参数可以被声明为一个具体类型（例如，int、string、或者*os.File以及MyType），也可以是借口（interface），即提供了具有满足该接口的方法的值。对于一个生命为借口的值，我们可以传入任意值，只要该值包含给借口所声明的方法。这点非常灵活而强大，特别是当它与Go语言所支持的访问嵌入字段的方法相结合时。

继承的一个优点是，有些方法只需在基类中实现一次，即可在子类中方便地使用。Go语言为此提供了两种解决方案。其中一种解决方案是使用切入，如果我们嵌入了一个类型，方法只需在所嵌入的类型中实现一次，即可在所有包含该嵌入类型的类型中使用。另一种解决方案是，为每一种类型提供独立的方法，但是只是简单地将包装（通常只有一行）了功能性作用的代码放进一个函数中，然后让所有类的方法都调用这个函数。

Go语言面向对象编程中另一个与众不同点是它的接口、值和方法都相互保持独立。接口用于声明方法签名，结构体用于声明聚合或者嵌入的值，而方法用于声明在自定义类型（通常为结构体）上的操作。在一个自定义类型的方法和任何特殊接口之间没有任何显式的联系。但是如果该类型的方法满足一个或多个接口，那么该类型的值可以用于任何该接口的值的地方。当然，每一个类型都满足空接口（interface{}），因此任何值都可以用于声明了空接口的地方。 

一种按Go语言的方式思考的方法是，把 is-a 关系看成由接口来定义，也就是方法的签名。而 has-a 关系可以使用聚合或者嵌入特定类型值的结构体来表达，这些定义构成自定义类型。

虽然没法为内置类型添加方法，但可以很容易地基于内置类型创建自定义类型，然后为其添加呢任何我们想要的方法。给类型的值可以调用我们提供的方法，同时也可以与它们底层类型提供的任何函数，方法以及操作符 一起使用。例如，假如我们有个类型声明type Integer int，我们可以不拘形式地使用整数的+操作符将这两种类型的值相加。并且，一旦我们有了一个自定义类型，我们也可以添加自定义的方法。例如，func  (i Integer) Double(i Integer {return i * 2}。

基于内置类型的自定义类型不但容易创建，运行时效率也非常高。将基于内置类型的自定义类型与该内置类型相互转换无需耗费运行时代价，因为这种转换能够在编译时完成。鉴于此，要使用自定义的方法时将内置类型“升级”成自定义类型，或者要将一个类型传入一个只接受内置类型参数的函数时将自定义类型“降级”成为内置类型，都是非常实用的做法。
## 2. 自定义类型
自定义类型使用Go语言的如下语法创建：
```
type typeName typeSpecification
```
typeName可以是一个包或者函数内唯一的任何合法的Go标识符。typeSpecification可以是任意内置的类型（如string， int，切片，映射或者通道）、一个接口、一个结构体或者一个函数签名。下面是一些没有方法的自定义类型例子：
```
type Count int
type StringMap map[string]string
type FloatChan chan float64
type FuncForRuneFunc func(rune) rune
```
在有些情况创建一个自定义类型就够了，但有些情况下我们需要给自定义类型添加一些方法来让它更实用。
### 2.1 添加方法
方法是作用在自定义类型的值上的一类特殊函数，通常自定义类型的值会被传递给该函数。该值可以以指针或者值的形式传递，这取决于方法如何定义。定义方法的语法几乎等同于定义函数，除了需要在func关键字和方法之间必须写上接收者（写入括号中）之外，该接收者即可以以该方法所属于的类型的形式出现，也可以以一个变量名及类型的形式出现。当调用方法的时候，其接收者变量被自动设为该方法调用所对应的值或指针。

我们可以为任何自定义类型添加一个或多个方法。一个方法的接收者总是一个该类型的值，或者该类型的指针。然而，对于任何一个给定的类型，每个方法名必须唯一。唯一名字要求的结果是，我们不能同时定义两个相同名字的方法，让其中一个的接收者为指针类型而另一个为值类型。另一结果是，不支持重载方法。也就是说，不能定义名字相同但是不同签名的方法。
```
type Count int
func (count *Count) Increment() {*count++ }
func (count *Count) Decrement() {*count-- }
func (count Count) IsZero() bool {return count == 0}
```
让我们再稍微多看一个更详细的自定义类型，这回是基于一个结构体定义：
```
type Part struct {
    Id    int                  //具名字段（聚合）
    Name string      //具名字段（聚合）
}

func (part *Part) LowerCase() {
    part.Name = strings.ToLower(part.Name)
}

func (part *Part) UpperCase() {
    part.Name = strings.ToUpper(part.Name)
}

func (part Part) String()  string {
    return fmt.Sprintf("<<%s %q>>", part.Id, part.Name)
}

func (part Part) HasPrefix(prefix string) bool {
    return strings.HasPrefix(part.Name, prefix)
}
```
为了演示它是如何工作的，我们创建了接收者为值类型的String()和HasPrefix()方法。当然，传值的话无法修改原始数据，而传递指针的话可以：
```
part := Part{5, "wrench"}
part.UpperCase()
part.Id += 11
fmt.Println(part, partHasPrefix("w"))
```
当创建的自定义类型是基于结构体时，我们可以使用其名字及一对大括号包围的初始值来创建该类型的值。

**类型的方法集是指可以被该类型的值所调用所有方法的集合**。

一个指向自定义类型的值的指针，它的方法集由为该类型定义的所有方法组成，无论这些方法接收的是一个值还是一个指针。如果在指针上调用一个接收值的方法，Go语言会聪明地将该指针解引用，并将指针所指的底层值作为方法的接收者。

一个自定义类型值的方法集则由为该类型定义的接收者类型为值类型的方法组成，但是不包括那些接收这类型为指针的方法。但这种限制通常并不像这里所说的那样，因为如果我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这可以借助于Go语言传值的地址的能力实现，前提是该值是可寻址的（即它是一个变量，一个解引用指针，一个数组或切片项，或者结构体中的一个可寻址字段）。因此，加入我们这样调用value.Method()，其中Method()需要一个指针接收者，而value是一个可寻址的值，Go语言会把这个调用等同于(&value).Method()。

*Count类型的方法集包含3个方法：Increment()、Decrement()和IsZero()。然而Count类型的方法集则只哟一个方法：IsZero()。所有这些方法都可以在*Count上调用。同时，正如我们在前面的代码片段上看到的，只要Count值是可寻址的，这些函数也可以在*Count值上调用。

将方法的接收者定义为值类型对于小数据类型来说是可行的，如数值类型。这些方法不能修改它们所调用的值，因为只能得到接收者的一个副本。如果我们的数据类型的值很大，或者需要修改值，则需要让方法接受一个指针类型的接收者，这样可以使得方法调用的开销尽可能的小。
### 2.2 验证类型
## 3. 接口
## 4. 结构体

## Reference
- [An Introduction to Programming in Go](http://www.golang-book.com/books/intro)