# Go 内存模型
## 介绍
Go内存模型指定了在什么条件下在一个goroutine中读取一个变量能够确保读到由其它goroutine写入的针对同一变量的值。
## 建议
程序中修改需要被多个goroutine同时访问的数据必须串行化读写操作（访问）。

为了串行化访问，可以利用通道操作（channel operation），或者同步原语如在[sync](https://golang.google.cn/pkg/sync/) 和 [sync/atomic](https://golang.google.cn/pkg/sync/atomic/)包中的那些来保护数据。

如果你必须阅读本文的剩下部分才能理解你的应用的行为，你就实在太聪明了。

不要聪明过头。
## 之前发生（Happens Before）
在一个简单的goroutine里，读写必须按照程序指定的顺序执行。即，只有当读写重拍不影响goroutine里由语言规范定义的行为时，编译器和处理器才有可能重排同意goroutine里的读写执行顺序。由于重排，一个goroutine观察到的执行顺序可能不同于另一个观察到的。例如，一个goroutine执行`a = 1; b = 2;`，另一个goroutine可能观察到b的更新值在先，a的更新值在后。

为了指定读和写的需求，我们定义了之前发生，一个go应用的内存操作的部分执行顺序。如果事件e1在事件e2之前发生，我们就说e2在e1之后发生。同理，如果e1既不在e2之前发生，也不再e2之后发生，我们就说e1和e2同时（并发）发生。

在同一个goroutine里，之前发生顺序是由程序指定的顺序。

只有在下面两个条件同时满足时，对一个变量v的写（w）才会被对该变量的读取（r）观察到：
1.  r不能发生在w之前
2.  在w之后以及在r之前，没有对v的另一个写入

为了保证对一个变量v的写（w）被对该变量的读取（r）观察到，确保观察的r只有一个w可以写入。即当下面两个条件同时满足时r可以确保观察到w：
1.  w发生在r之前
2.  对共享变量v的写入要么在w之前，要么在r之后

这一对条件比上一对条件更严格；它要求不能有与w和r的并行写操作。

在一个简单goroutine里，没有并行，因此两个定义是相同的：一个读取操作r可以读到由最近的写入操作w对v的更新。当多个goroutine共享一个变量v时，它们必须使用同步事件来建立之前发生的条件，以此确保读取能够观察到写入（的数据）。

对变量v的按其变量类型以0值初始化就像在内存模型中的写入一样。

读写超过一个机器字大小的值就像读取多个机器子的行为一样，没有顺序。
## 同步
## 不正确的同步

## Reference
- [The Go Memory Model](https://golang.google.cn/ref/mem)